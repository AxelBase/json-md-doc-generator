import{S as f,i as k,s as M,n as v,d as s,c as p,b as w,m as e,q as _,e as n,h as T,p as x,j as o,k as j}from"../chunks/l8Oz43E9.js";import"../chunks/IHki7fMi.js";import{b as g}from"../chunks/808LiJSo.js";const C=!0,J=Object.freeze(Object.defineProperty({__proto__:null,prerender:C},Symbol.toStringTag,{value:"Module"}));function A(b){let a,i,u,c,m,d,h,r,y=`<div class="breadcrumbs svelte-1m5u35w"><a href="${g}/blog" class="svelte-1m5u35w">Blog</a> <span>/</span> <p class="svelte-1m5u35w">Understanding the Core Conversion Rules</p></div> <article class="prose svelte-1m5u35w"><h1 class="svelte-1m5u35w">Understanding the Core Conversion Rules</h1> <p class="post-meta svelte-1m5u35w">Published: January 07, 2026</p> <p class="svelte-1m5u35w">The JSON to Markdown Doc Generator applies a set of clear, consistent rules to transform JSON structures into readable Markdown. Knowing these rules helps predict and optimize output for documentation needs.</p> <p class="svelte-1m5u35w">Root-level keys in the JSON object become second-level Markdown headings using the key name as title text. This creates a natural table of contents for the document.</p> <p class="svelte-1m5u35w">Primitive values—strings, numbers, booleans, or null—appear as paragraph text or simple key-value presentations under their heading.</p> <h2 class="svelte-1m5u35w">Array Handling Rules</h2> <ul class="svelte-1m5u35w"><li class="svelte-1m5u35w">Arrays of primitive values render as bullet lists</li> <li class="svelte-1m5u35w">Arrays of objects generate full Markdown tables</li> <li class="svelte-1m5u35w">Empty arrays show as empty lists or tables</li></ul> <p class="svelte-1m5u35w">For primitive arrays, each item becomes a list entry. This works well for enumerations like tags, categories, or status options.</p> <p class="svelte-1m5u35w">When arrays contain objects, the tool extracts all unique keys across items to form table headers. Each object fills a row, with cells aligned properly. Missing properties result in empty cells, ensuring table consistency.</p> <p class="svelte-1m5u35w">Object values trigger recursive processing. Child keys become third-level headings, maintaining the hierarchical outline.</p> <p class="svelte-1m5u35w">Key order is preserved deterministically, guaranteeing identical output from identical input. This reproducibility is essential for version control and audits.</p> <p class="svelte-1m5u35w">Tables include proper piping and alignment syntax compatible with all Markdown renderers, including GitHub and static site generators.</p> <p class="svelte-1m5u35w">These rules strike a balance between fidelity to the source data and readability in the target format. Headings provide structure, lists offer simplicity, and tables handle relational data effectively.</p> <p class="svelte-1m5u35w">Understanding the mappings allows users to structure JSON intentionally for better documentation outcomes. Descriptive keys produce meaningful headings, and consistent object shapes yield cleaner tables.</p> <p class="svelte-1m5u35w">The predictable behavior makes the tool reliable for integration into larger workflows where automated documentation generation is required.</p> <h2 class="svelte-1m5u35w">Frequently Asked Questions</h2> <details class="svelte-1m5u35w"><summary class="svelte-1m5u35w">How are table headers determined?</summary> <p class="svelte-1m5u35w">From the union of all keys in array objects.</p></details> <details class="svelte-1m5u35w"><summary class="svelte-1m5u35w">What happens with mixed array types?</summary> <p class="svelte-1m5u35w">Arrays must be uniform; mixed types may produce unexpected results.</p></details> <details class="svelte-1m5u35w"><summary class="svelte-1m5u35w">Can I influence the output format?</summary> <p class="svelte-1m5u35w">Currently rules are fixed for consistency.</p></details> <p class="italic-note svelte-1m5u35w">Master these rules to create professional documentation from JSON sources.</p></article>`;return{c(){a=o("meta"),i=o("meta"),u=o("meta"),c=o("meta"),m=o("meta"),d=o("meta"),h=j(),r=o("div"),r.innerHTML=y,this.h()},l(l){const t=_("svelte-1ol947w",document.head);a=n(t,"META",{name:!0,content:!0}),i=n(t,"META",{property:!0,content:!0}),u=n(t,"META",{property:!0,content:!0}),c=n(t,"META",{property:!0,content:!0}),m=n(t,"META",{property:!0,content:!0}),d=n(t,"META",{name:!0,content:!0}),t.forEach(s),h=T(l),r=n(l,"DIV",{class:!0,"data-svelte-h":!0}),x(r)!=="svelte-ajezv5"&&(r.innerHTML=y),this.h()},h(){document.title="Understanding the Core Conversion Rules | Blog",e(a,"name","description"),e(a,"content","Detailed explanation of how JSON keys become Markdown headings, primitive arrays turn into bullet lists, and object arrays are rendered as tables."),e(i,"property","og:title"),e(i,"content","Understanding the Core Conversion Rules | Blog"),e(u,"property","og:description"),e(u,"content","Detailed explanation of how JSON keys become Markdown headings, primitive arrays turn into bullet lists, and object arrays are rendered as tables."),e(c,"property","og:url"),e(c,"content",g+"/blog/posts/post4"),e(m,"property","og:type"),e(m,"content","article"),e(d,"name","twitter:card"),e(d,"content","summary_large_image"),e(r,"class","container fade-in post-layout svelte-1m5u35w")},m(l,t){p(document.head,a),p(document.head,i),p(document.head,u),p(document.head,c),p(document.head,m),p(document.head,d),w(l,h,t),w(l,r,t)},p:v,i:v,o:v,d(l){l&&(s(h),s(r)),s(a),s(i),s(u),s(c),s(m),s(d)}}}class N extends f{constructor(a){super(),k(this,a,null,A,M,{})}}export{N as component,J as universal};
